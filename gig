#!/usr/bin/env python
# 
# TODO:
#   Should probably consider refactoring a bit.
#   Fetch-from-svn ability
#   Local cache of django downloads
#   Using existing django install
#   ... anything further probably warrants using zc.buidout or something like that
"""
This script aims at providing a simple way to bootstrap a self-contained django project.

In short, it makes a few trivial decisions for you.

To those who use the Django framework this may seem a bit unecessary, but I believe that
it could be easier to get started with django, without having to impose minor decisions 
on new users such as where to place templates and basic media files.

    $ gig myproject
    
Will create:

    myproject/
        lib/
        lib/django/
        config/__init__.py
        config/urls.py
        config/settings/
        config/settings/__init__.py
        config/settings/base.py
        templates/
        media/
        script/
        script/manage
        

A bit about this layout.

    lib/
    
This is added to PYTHONPATH, so any new apps should go in here, as well as any existing 
django apps you might want to use

    config/

The project-wide config files (what `startproject` would typically generate, mostly).  Of
note are `urls.py` and...

    config/settings/
    
This is a module hoding `base.py`, used as the general config, and any host-specific configs.
For example, on my home machine I might have `config/settings/home.py` with paths specific to 
that setup, while at work I might have `config/settings/office.py`.  Or development and production
configs, of course.  Basically the same deal as Rails environments.

    templates/

App tempaltes.

    media/
    
App media (maybe, there is that whole deal of )

    script/manage
    
The usual manage.py created from `django-admin startproject`, but tweaked to deal with it's location.

"""
import sys, os, stat
import urllib
import tarfile
import tempfile
import fileinput


from optparse import OptionParser

def pfile(s):
    """Shortcut for getting full file paths"""
    return "%s/%s" % (pdir, s)
    
def log(s):
    "This will at some point be more useful..."
    if options.verbose:
        print s

def buildTree():
    makeFolder(pname)
    makeFolder(pfile('lib'))
    makeFolder(pfile('config'))
    makeFolder(pfile('config/settings'))
    makeFolder(pfile('templates'))
    makeFolder(pfile('media'))
    makeFolder(pfile('script'))

def makeFolder(path):
    "TODO: check if folder exists, report accordingly"
    log("creating: %s" % path)
    
    try:
        os.mkdir(path)
    except OSError:
        log("...already exists")

def copyToLib(url):
    f = urllib.urlretrieve(url)
    return f[0]

def installDjagno():
    
    log("fetching %s" % django_url)
    
    filename = copyToLib(django_url)
    
    tar = tarfile.open(filename, "r:gz")
    
    tempdir = tempfile.mkdtemp()
    
    # FIXME
    log("extracting Django-%s.tar.gz" % djver)    
    tar.extractall(tempdir)
    
    # FIXME
    log ("moving Django-%s/django to project/lib/django" % djver)
    os.rename('%s/Django-%s-final/django' % (tempdir, djver), '%s/lib/django' % pname)
    
    tar.close()
    
    # Erm, tempdir cleanup?
    

def makeManageScript():
    
    script = """#!/usr/bin/env python 
# TODO: non-standard pythons installs

import sys, os

# Add project-specific modules to pythonpath.
# We have to insert it in the beginning to avoid an
# installed Django getting picked up instead
basedir = os.path.normpath ( '%s/..' % os.path.split( os.path.abspath( sys.argv[0]) )[0] )
sys.path[1:1] = ['%s/config' % basedir, '%s/lib' % basedir]

from django.core.management import execute_manager

try:
    # TODO: import non-base config, eg 'hostname' or 'development'
    from settings import development as settings
except ImportError:
    import sys
    sys.stderr.write("Error: Can't import settings")
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)


    """
    filename = pfile('script/manage.py')
    f = open(filename, 'w')
    f.write(script)
    f.close()

    # Maxe executable
    statinfo = os.stat(filename)
    permissions = stat.S_IEXEC | statinfo[0]
    os.chmod(filename, permissions)
    

def customizeProject():
    
    settings_file = pfile('config/settings/development.py')
    
    settings = """
from base import *

DATABASE_ENGINE = 'sqlite3'    # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = 'devel.db'     # Or path to database file if using sqlite3.

MEDIA_ROOT = "%(media_root)s"

TEMPLATE_DIRS = (
    "%(templates)s",
)

    """ % {'templates': pfile('templates/'), 'media_root': pfile('media/')}

    f = open(settings_file, "w")
    f.write(settings)
    f.close()
    
def customizeDefaultSettings():
    
    manipFile(
        pfile('config/settings/base.py'), 
        lambda s: s.replace("ROOT_URLCONF = '%s.urls'" % pname, "ROOT_URLCONF = 'urls'")
        )
            
    
def setupProjectFiles():
    
    from django.core import management
    management.base.copy_helper(None, 'project', pname, pname)
    
    os.unlink('%s/%s/manage.py' % (pname, pname))
    os.unlink('%s/%s/__init__.py' % (pname, pname))
    
    os.rename('%s/%s/settings.py' % (pname, pname), '%s/config/settings/base.py' % pname)
    os.rename('%s/%s/urls.py' % (pname, pname), '%s/config/urls.py' % pname)
    
    os.rmdir('%s/%s' % (pname, pname))
    
    # Make config/settings/ a module
    f = open( pfile('config/settings/__init__.py'), 'w')
    f.write('#\n')
    f.close()

def manipFile(filename, method):
    "Run supplied method over each line in the file, saving result over original file"
    f = open(filename, 'r+')
    out = []
    for line in f:
        out.append( method(line) )
    
    f.seek(0)
    f.writelines(out)
    f.truncate()
    f.close()
    
    
#############################################################################
# Option Parsing
#############################################################################

parser = OptionParser()

parser.add_option("-u", "--unpack", 
    action="store_true", dest="unpack", default=False,
    help="IGNORED - Unpack django to lib/")
                
parser.add_option("-V", "--django-version",
    action="store", dest="django_version", default="1.0.2",
    help="Django version to use.  This will be downloaded. Non-version numbers will be interpreted from the django svn repository")

parser.add_option("-f", "--file",
    action="store", type="string", dest="filename")
                
parser.add_option("-q", "--quiet",
    action="store_false", dest="verbose", default=True,
    help="don't print status messages to stdout")


(options, args) = parser.parse_args()

#############################################################################
# The Procedural Bits
#############################################################################

pname = os.path.basename(args[0])
djver = options.django_version

# FIXME: Only works when creating project in cwd!
pdir = os.path.normpath( "%s/%s" % (os.getcwd(), pname))

# Meh, how to get cwd?
#pdir = os.path.normpath (os.path.split( os.path.abspath( sys.argv[0]) )[0] )


django_url = 'http://media.djangoproject.com/releases/%s/Django-%s-final.tar.gz' % (djver, djver)
#django_url = 'http://localhost/~tvon/Django-%s-final.tar.gz' % djver

buildTree()
installDjagno()
makeManageScript()
customizeProject()


# Django should be available now...
sys.path[1:1] = [pfile('lib/')]
import django
setupProjectFiles()
customizeDefaultSettings()