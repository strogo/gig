#!/usr/bin/env python
# 
# TODO:
#   Make 'script/manage startapp foo' buildout in the right place
#   Should probably consider refactoring a bit.
#   Fetch-from-svn ability
#   Using existing django install
#   ... anything further probably warrants using zc.buidout or something like that
"""

Note:

 Make this a "suped-up" django-admin/manage script and copy it to the script/ folder when done?  This would mean:
 * Adding a few commands, eg "app install" to install 3rd party apps into lib/
 * Perhaps allowing system-wide gig to start individual instances
 * Perhaps adding lib/gig which would include TTW based tools for managing installed apps.
 
 
In short

    $ curl -o gig http://github.com/tvon/gig/blah/blah
    $ ./gig myproject
    
    
XXXXXXXXXXXXXXXX
    
This is a script that will make a few trivial decisions for you while setting up a 
pre-organized Django project tree.

To those who use the Django framework this may seem a bit unecessary, but I believe that
it could be easier to get started with django, without having to impose minor decisions 
on new users such as where to place templates and basic media files.

    $ gig myproject
    
Will create:

    myproject/
        lib/
        lib/django/
        config/__init__.py
        config/urls.py
        config/settings/
        config/settings/__init__.py
        config/settings/base.py
        config/settings/`hostname`.py # Hostname here is taken from platform.node()
        templates/
        media/
        script/
        script/manage.py
        
A bit about this layout.

    lib/
    
This is added to PYTHONPATH, so any new apps should go in here, as well as any existing 
django apps you might want to use

    config/

The project-wide config files (what `startproject` would typically generate, mostly).  Of
note are `urls.py` and...

    config/settings/
    
This is a module hoding `base.py`, used as the general config, and any host-specific configs.
For example, on my home machine I might have `config/settings/home.py` with paths specific to 
that setup, while at work I might have `config/settings/office.py`.  Or development and production
configs, of course.  Basically the same deal as Rails environments.

    templates/

App tempaltes.

    media/
    
App media (maybe, there is that whole deal of )

    script/manage.py
    
The usual manage.py created from `django-admin startproject`, but tweaked to deal with it's location.

"""
import sys, os, stat
import urllib
import tarfile
import tempfile
import fileinput
import platform

from optparse import OptionParser

try:
    import django
except ImportError:
    django = False


#def makeManageScript(basedir):
#    
#    script = """#!/usr/bin/env python 
## TODO: non-standard pythons installs
#
#import sys, os
#
## Add project-specific modules to pythonpath.
## We have to insert it in the beginning to avoid an
## installed Django getting picked up instead
#basedir = os.path.normpath ( '%s/..' % os.path.split( os.path.abspath( sys.argv[0]) )[0] )
#sys.path[1:1] = ['%s/config' % basedir, '%s/lib' % basedir]
#
#from django.core.management import execute_manager
#
#try:
#    # TODO: import non-base config, eg 'hostname' or 'development'
#    from settings import development as settings
#except ImportError:
#    import sys
#    sys.stderr.write("Error: Can't import settings")
#    sys.exit(1)
#
#if __name__ == "__main__":
#    execute_manager(settings)
#    """
#    filename = '%s/script/manage.py' % basedir
#    f = open(filename, 'w')
#    f.write(script)
#    f.close()
#
#    # Maxe executable
#    statinfo = os.stat(filename)
#    permissions = stat.S_IEXEC | statinfo[0]
#    os.chmod(filename, permissions)
    

#############################################################################
# Option Parsing
#############################################################################

parser = OptionParser()

parser.add_option("-V", "--django-version",
    action="store", dest="django_version", default="1.0.2",
    help="Django version to use.  This will be downloaded. Non-version numbers will be interpreted from the django svn repository")

parser.add_option("-f", "--file",
    action="store", type="string", dest="filename")
                
parser.add_option("-q", "--quiet",
    action="store_false", dest="verbose", default=True,
    help="don't print status messages to stdout")


(options, args) = parser.parse_args()


#############################################################################
# Reworking
#############################################################################


URLS_PY = """from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^example/', include('example.foo.urls')),

    # Serve up static files for development
    (r'^static/(?P<path>.*)$', 'django.views.static.serve', {'document_root': settings.MEDIA_ROOT}),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs' 
    # to INSTALLED_APPS to enable admin documentation:
    (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    (r'^admin/', include(admin.site.urls)),
)
"""

DEVELOPMENT_PY = """
from base import *

DATABASE_ENGINE = 'sqlite3'    # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = 'devel.db'     # Or path to database file if using sqlite3.

MEDIA_URL = '/static/'

MEDIA_ROOT = '{{ path }}/media/'

TEMPLATE_DIRS = (
    '{{ path }}/templates/',
)

"""

DJANGO_WSGI = """
import os, sys
sys.path.append('/usr/local/django')
os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

import django.core.handlers.wsgi

application = django.core.handlers.wsgi.WSGIHandler()
"""

APACHE_CONF = """
Alias /media/ /usr/local/django/mysite/media/

<Directory /usr/local/django/mysite/media>
    Order deny,allow
    Allow from all
</Directory>

WSGIScriptAlias / /usr/local/django/mysite/apache/django.wsgi

<Directory /usr/local/django/mysite/apache>
    Order deny,allow
    Allow from all
</Directory>
"""
class Project(object):
    
    def __init__(self, path, target=None):
        """Takes full project path"""
        self.target = target if target != None else path
        self.path = path
        self.hostname = platform.node()
        
    def mapFile(self, path, mapper):
        data = file(path, 'r').read()
        file(path, 'w+').write(mapper(data))
        
    def moveFiles(self):
        # XXX: this is a bit silly, should just create the files or move them
        # from django instead of building out a project and moving them...
        os.unlink('%s/manage.py' % self.path)
        os.unlink('%s/__init__.py' % self.path)
        os.unlink('%s/urls.py' % self.path)
                
        os.rename('%s/settings.py' % self.path, '%s/config/settings/base.py' % self.target)
        
        urls = open('%s/config/urls.py' % self.target, 'w')
        urls.write(URLS_PY)
        urls.close()
        
        devsettings = open('%s/config/settings/%s.py' % (self.target, self.hostname), 'w')
        devsettings.write(DEVELOPMENT_PY.replace('{{ path }}', self.path))
        devsettings.close()
        
        # Make config/settings/ a module
        f = open( '%s/config/settings/__init__.py' % self.target, 'w')
        f.write('#\n')
        f.close()
        
    def urlconfTweak(self):
        pass

class GigProject(object):
    
    def __init__(self, options, args):
        self.options = options
        self.args = args
        self.name = os.path.basename(args[0])
        self.path = os.path.abspath( os.path.expanduser( args[0] ) )
        self.tree_exists = False;
        
    def log(self, s):
        print s
        
    def mkdir(self, path):
        self.log("Creating %s" % path)
        try:
            os.mkdir(path)
        except OSError:
            self.log("...already exists")
    
    def makeTree(self):
        self.mkdir(self.name)
        for p in ('app', 'config', 'config/settings', 'templates', 'media', 'media/js', 'media/img', 'media/css', 'script'):
            self.mkdir('%s/%s' % (self.path, p))
        
        self.tree_exists = True;
    
    def createProject(self):
        from django.core import management
        
        if not self.tree_exists:
            self.makeTree()
        
        management.base.copy_helper(None, 'project', self.name, self.path)
        
        project = Project('%s/%s' % (self.path, self.name), self.path)
        project.moveFiles()

    def writeFile(self, path, content):
        """Write content to file represented by path, relative to project root"""
        f = open('%s/%s' % (self.path, path), 'w+')
        f.write(content)
        f.close()
        
#############################################################################
# The Procedural Bits
#############################################################################

gig = GigProject(options, args)
gig.createProject()

MANAGE_SCRIPT = """#!/usr/bin/env python 
import sys, os

basedir = '%(basedir)s'
sys.path[1:1] = ['%%s/config' %% basedir, '%%s/lib' %% basedir]

from django.core.management import execute_manager

try:
    from settings import settings
except ImportError:
    import sys
    sys.stderr.write("Error: Can't import settings")
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)
""" % {'basedir': gig.path}

SETTINGS_INIT = """
import platform

hostname = platform.node()

try:
    settings = __import__(hostname, globals(), locals(), [], -1)
except:
    print "Unable to import host-specific settings module '%s', falling back to 'base'"
    import base as settings

"""

gig.writeFile('config/settings/__init__.py', SETTINGS_INIT)
gig.writeFile('script/manage.py', MANAGE_SCRIPT)
